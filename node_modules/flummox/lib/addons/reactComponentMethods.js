'use strict';

exports.__esModule = true;
exports.staticProperties = exports.instanceMethods = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Flux = require('../Flux');

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var instanceMethods = {
  getChildContext: function getChildContext() {
    var flux = this.getFlux();

    if (!flux) return {};

    return { flux: flux };
  },
  getFlux: function getFlux() {
    return this.props.flux || this.context.flux;
  },
  initialize: function initialize() {
    this._fluxStateGetters = [];
    this._fluxListeners = {};
    this.flux = this.getFlux();

    if (!(this.flux instanceof _Flux.Flux)) {
      // TODO: print the actual class name here
      throw new Error('fluxMixin: Could not find Flux instance. Ensure that your component ' + 'has either `this.context.flux` or `this.props.flux`.');
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    var flux = this.getFlux();

    for (var key in this._fluxListeners) {
      if (!this._fluxListeners.hasOwnProperty(key)) continue;

      var store = flux.getStore(key);
      if (typeof store === 'undefined') continue;

      var listener = this._fluxListeners[key];

      store.removeListener('change', listener);
    }
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    this.updateStores(nextProps);
  },
  updateStores: function updateStores() {
    var props = arguments.length <= 0 || arguments[0] === undefined ? this.props : arguments[0];

    var state = this.getStoreState(props);
    this.setState(state);
  },
  getStoreState: function getStoreState() {
    var props = arguments.length <= 0 || arguments[0] === undefined ? this.props : arguments[0];

    return this._fluxStateGetters.reduce(function (result, stateGetter) {
      var getter = stateGetter.getter;
      var stores = stateGetter.stores;

      var stateFromStores = getter(stores, props);
      return (0, _objectAssign2.default)(result, stateFromStores);
    }, {});
  },

  /**
   * Connect component to stores, get the combined initial state, and
   * subscribe to future changes. There are three ways to call it. The
   * simplest is to pass a single store key and, optionally, a state getter.
   * The state getter is a function that takes the store as a parameter and
   * returns the state that should be passed to the component's `setState()`.
   * If no state getter is specified, the default getter is used, which simply
   * returns the entire store state.
   *
   * The second form accepts an array of store keys. With this form, the state
   * getter is called once with an array of store instances (in the same order
   * as the store keys). the default getter performance a reduce on the entire
   * state for each store.
   *
   * The last form accepts an object of store keys mapped to state getters. As
   * a shortcut, you can pass `null` as a state getter to use the default
   * state getter.
   *
   * Returns the combined initial state of all specified stores.
   *
   * This way you can write all the initialization and update logic in a single
   * location, without having to mess with adding/removing listeners.
   *
   * @type {string|array|object} stateGetterMap - map of keys to getters
   * @returns {object} Combined initial state of stores
   */
  connectToStores: function connectToStores() {
    var _this = this;

    var stateGetterMap = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var stateGetter = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    var flux = this.getFlux();

    var getStore = function getStore(key) {
      var store = flux.getStore(key);

      if (typeof store === 'undefined') {
        throw new Error('connectToStores(): Store with key \'' + key + '\' does not exist.');
      }

      return store;
    };

    if (typeof stateGetterMap === 'string') {
      var key = stateGetterMap;
      var store = getStore(key);
      var getter = stateGetter || defaultStateGetter;

      this._fluxStateGetters.push({ stores: store, getter: getter });
      var listener = createStoreListener(this, store, getter);

      store.addListener('change', listener);
      this._fluxListeners[key] = listener;
    } else if (Array.isArray(stateGetterMap)) {
      (function () {
        var stores = stateGetterMap.map(getStore);
        var getter = stateGetter || defaultReduceStateGetter;

        _this._fluxStateGetters.push({ stores: stores, getter: getter });
        var listener = createStoreListener(_this, stores, getter);

        stateGetterMap.forEach(function (key, index) {
          var store = stores[index];
          store.addListener('change', listener);
          _this._fluxListeners[key] = listener;
        });
      })();
    } else {
      for (var key in stateGetterMap) {
        var store = getStore(key);
        var getter = stateGetterMap[key] || defaultStateGetter;

        this._fluxStateGetters.push({ stores: store, getter: getter });
        var listener = createStoreListener(this, store, getter);

        store.addListener('change', listener);
        this._fluxListeners[key] = listener;
      }
    }

    return this.getStoreState();
  }
}; /**
    * React Component methods. These are the primitives used to implement
    * fluxMixin and FluxComponent.
    *
    * Exposes a Flux instance as `this.flux`. This requires that flux be passed as
    * either context or as a prop (prop takes precedence). Children also are given
    * access to flux instance as `context.flux`.
    *
    * It also adds the method `connectToStores()`, which ensures that the component
    * state stays in sync with the specified Flux stores. See the inline docs
    * of `connectToStores` for details.
    */

var staticProperties = {
  contextTypes: {
    flux: _react.PropTypes.instanceOf(_Flux.Flux)
  },

  childContextTypes: {
    flux: _react.PropTypes.instanceOf(_Flux.Flux)
  },

  propTypes: {
    connectToStores: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.arrayOf(_react.PropTypes.string), _react.PropTypes.object]),
    flux: _react.PropTypes.instanceOf(_Flux.Flux),
    render: _react2.default.PropTypes.func,
    stateGetter: _react2.default.PropTypes.func
  }
};

exports.instanceMethods = instanceMethods;
exports.staticProperties = staticProperties;

function createStoreListener(component, store, storeStateGetter) {
  return (function () {
    var state = storeStateGetter(store, this.props);
    this.setState(state);
  }).bind(component);
}

function defaultStateGetter(store) {
  return store.getStateAsObject();
}

function defaultReduceStateGetter(stores) {
  return stores.reduce(function (result, store) {
    return (0, _objectAssign2.default)(result, store.getStateAsObject());
  }, {});
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hZGRvbnMvcmVhY3RDb21wb25lbnRNZXRob2RzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLElBQU0sZUFBZSxHQUFHO0FBRXRCLGlCQUFlLDZCQUFHO0FBQ2hCLFFBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQzs7QUFFNUIsUUFBSSxDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQzs7QUFFckIsV0FBTyxFQUFFLElBQUksRUFBSixJQUFJLEVBQUUsQ0FBQztHQUNqQjtBQUVELFNBQU8scUJBQUc7QUFDUixXQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO0dBQzdDO0FBRUQsWUFBVSx3QkFBRztBQUNYLFFBQUksQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLENBQUM7QUFDNUIsUUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFFLENBQUM7QUFDekIsUUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7O0FBRTNCLFFBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxrQkF0QlYsSUFBSSxDQXNCc0IsQUFBQyxFQUFFOztBQUVoQyxZQUFNLElBQUksS0FBSyxDQUNiLCtIQUMwRCxDQUMzRCxDQUFDO0tBQ0g7R0FDRjtBQUVELHNCQUFvQixrQ0FBRztBQUNyQixRQUFNLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7O0FBRTVCLFNBQUssSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtBQUNuQyxVQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUUsU0FBUzs7QUFFdkQsVUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNqQyxVQUFJLE9BQU8sS0FBSyxLQUFLLFdBQVcsRUFB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SnFCLFNBQVMsQ0ErSnBCLE1BQU0sRUFDaEIsT0FoS3FCLFNBQVMsQ0FnS3BCLE9BQU8sQ0FBQyxPQWhLRyxTQUFTLENBZ0tGLE1BQU0sQ0FBQyxFQUNuQyxPQWpLcUIsU0FBUyxDQWlLcEIsTUFBTSxDQUNqQixDQUFDO0FBQ0YsUUFBSSxFQUFFLE9BbktpQixTQUFTLENBbUtoQixVQUFVLE9BbEtyQixJQUFJLENBa0t1QjtBQUNoQyxVQUFNLEVBQUUsUUFwS0gsT0FBTyxDQW9LRSxTQUFTLENBQUMsSUFBSTtBQUM1QixlQUFXLEVBQUUsUUFyS1IsT0FBTyxDQXFLTyxTQUFTLENBQUMsSUFBSTtHQUNsQztDQUNGLENBQUM7O1FBRU8sZUFBZSxHQUFmLGVBQWU7UUFBRSxnQkFBZ0IsR0FBaEIsZ0JBQWdCOztBQUUxQyxTQUFTLG1CQUFtQixDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUU7QUFDL0QsU0FBTyxDQUFBLFlBQVc7QUFDaEIsUUFBTSxLQUFLLEdBQUcsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNsRCxRQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0dBQ3RCLENBQUEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7Q0FDbkI7O0FBRUQsU0FBUyxrQkFBa0IsQ0FBQyxLQUFLLEVBQUU7QUFDakMsU0FBTyxLQUFLLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztDQUNqQzs7QUFFRCxTQUFTLHdCQUF3QixDQUFDLE1BQU0sRUFBRTtBQUN4QyxTQUFPLE1BQU0sQ0FBQyxNQUFNLENBQ2xCLFVBQUMsTUFBTSxFQUFFLEtBQUs7V0FBSyw0QkFBTyxNQUFNLEVBQUUsS0FBSyxDQUFDLGdCQUFnQixFQUFFLENBQUM7R0FBQSxFQUMzRCxFQUFFLENBQ0gsQ0FBQztDQUNIIiwiZmlsZSI6InJlYWN0Q29tcG9uZW50TWV0aG9kcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVhY3QgQ29tcG9uZW50IG1ldGhvZHMuIFRoZXNlIGFyZSB0aGUgcHJpbWl0aXZlcyB1c2VkIHRvIGltcGxlbWVudFxuICogZmx1eE1peGluIGFuZCBGbHV4Q29tcG9uZW50LlxuICpcbiAqIEV4cG9zZXMgYSBGbHV4IGluc3RhbmNlIGFzIGB0aGlzLmZsdXhgLiBUaGlzIHJlcXVpcmVzIHRoYXQgZmx1eCBiZSBwYXNzZWQgYXNcbiAqIGVpdGhlciBjb250ZXh0IG9yIGFzIGEgcHJvcCAocHJvcCB0YWtlcyBwcmVjZWRlbmNlKS4gQ2hpbGRyZW4gYWxzbyBhcmUgZ2l2ZW5cbiAqIGFjY2VzcyB0byBmbHV4IGluc3RhbmNlIGFzIGBjb250ZXh0LmZsdXhgLlxuICpcbiAqIEl0IGFsc28gYWRkcyB0aGUgbWV0aG9kIGBjb25uZWN0VG9TdG9yZXMoKWAsIHdoaWNoIGVuc3VyZXMgdGhhdCB0aGUgY29tcG9uZW50XG4gKiBzdGF0ZSBzdGF5cyBpbiBzeW5jIHdpdGggdGhlIHNwZWNpZmllZCBGbHV4IHN0b3Jlcy4gU2VlIHRoZSBpbmxpbmUgZG9jc1xuICogb2YgYGNvbm5lY3RUb1N0b3Jlc2AgZm9yIGRldGFpbHMuXG4gKi9cblxuaW1wb3J0IHsgZGVmYXVsdCBhcyBSZWFjdCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRmx1eCB9IGZyb20gJy4uL0ZsdXgnO1xuaW1wb3J0IGFzc2lnbiBmcm9tICdvYmplY3QtYXNzaWduJztcblxuY29uc3QgaW5zdGFuY2VNZXRob2RzID0ge1xuXG4gIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICBjb25zdCBmbHV4ID0gdGhpcy5nZXRGbHV4KCk7XG5cbiAgICBpZiAoIWZsdXgpIHJldHVybiB7fTtcblxuICAgIHJldHVybiB7IGZsdXggfTtcbiAgfSxcblxuICBnZXRGbHV4KCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmZsdXggfHwgdGhpcy5jb250ZXh0LmZsdXg7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLl9mbHV4U3RhdGVHZXR0ZXJzID0gW107XG4gICAgdGhpcy5fZmx1eExpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuZmx1eCA9IHRoaXMuZ2V0Rmx1eCgpO1xuXG4gICAgaWYgKCEodGhpcy5mbHV4IGluc3RhbmNlb2YgRmx1eCkpIHtcbiAgICAgIC8vIFRPRE86IHByaW50IHRoZSBhY3R1YWwgY2xhc3MgbmFtZSBoZXJlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBmbHV4TWl4aW46IENvdWxkIG5vdCBmaW5kIEZsdXggaW5zdGFuY2UuIEVuc3VyZSB0aGF0IHlvdXIgY29tcG9uZW50IGBcbiAgICAgICsgYGhhcyBlaXRoZXIgXFxgdGhpcy5jb250ZXh0LmZsdXhcXGAgb3IgXFxgdGhpcy5wcm9wcy5mbHV4XFxgLmBcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNvbnN0IGZsdXggPSB0aGlzLmdldEZsdXgoKTtcblxuICAgIGZvciAobGV0IGtleSBpbiB0aGlzLl9mbHV4TGlzdGVuZXJzKSB7XG4gICAgICBpZiAoIXRoaXMuX2ZsdXhMaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG5cbiAgICAgIGNvbnN0IHN0b3JlID0gZmx1eC5nZXRTdG9yZShrZXkpO1xuICAgICAgaWYgKHR5cGVvZiBzdG9yZSA9PT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBsaXN0ZW5lciA9IHRoaXMuX2ZsdXhMaXN0ZW5lcnNba2V5XTtcblxuICAgICAgc3RvcmUucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB0aGlzLnVwZGF0ZVN0b3JlcyhuZXh0UHJvcHMpO1xuICB9LFxuXG4gIHVwZGF0ZVN0b3Jlcyhwcm9wcyA9IHRoaXMucHJvcHMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RvcmVTdGF0ZShwcm9wcyk7XG4gICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gIH0sXG5cbiAgZ2V0U3RvcmVTdGF0ZShwcm9wcyA9IHRoaXMucHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5fZmx1eFN0YXRlR2V0dGVycy5yZWR1Y2UoXG4gICAgICAocmVzdWx0LCBzdGF0ZUdldHRlcikgPT4ge1xuICAgICAgICBjb25zdCB7IGdldHRlciwgc3RvcmVzIH0gPSBzdGF0ZUdldHRlcjtcbiAgICAgICAgY29uc3Qgc3RhdGVGcm9tU3RvcmVzID0gZ2V0dGVyKHN0b3JlcywgcHJvcHMpO1xuICAgICAgICByZXR1cm4gYXNzaWduKHJlc3VsdCwgc3RhdGVGcm9tU3RvcmVzKTtcbiAgICAgIH0sIHt9XG4gICAgKTtcbiAgfSxcblxuICAgLyoqXG4gICAgKiBDb25uZWN0IGNvbXBvbmVudCB0byBzdG9yZXMsIGdldCB0aGUgY29tYmluZWQgaW5pdGlhbCBzdGF0ZSwgYW5kXG4gICAgKiBzdWJzY3JpYmUgdG8gZnV0dXJlIGNoYW5nZXMuIFRoZXJlIGFyZSB0aHJlZSB3YXlzIHRvIGNhbGwgaXQuIFRoZVxuICAgICogc2ltcGxlc3QgaXMgdG8gcGFzcyBhIHNpbmdsZSBzdG9yZSBrZXkgYW5kLCBvcHRpb25hbGx5LCBhIHN0YXRlIGdldHRlci5cbiAgICAqIFRoZSBzdGF0ZSBnZXR0ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBzdG9yZSBhcyBhIHBhcmFtZXRlciBhbmRcbiAgICAqIHJldHVybnMgdGhlIHN0YXRlIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgY29tcG9uZW50J3MgYHNldFN0YXRlKClgLlxuICAgICogSWYgbm8gc3RhdGUgZ2V0dGVyIGlzIHNwZWNpZmllZCwgdGhlIGRlZmF1bHQgZ2V0dGVyIGlzIHVzZWQsIHdoaWNoIHNpbXBseVxuICAgICogcmV0dXJucyB0aGUgZW50aXJlIHN0b3JlIHN0YXRlLlxuICAgICpcbiAgICAqIFRoZSBzZWNvbmQgZm9ybSBhY2NlcHRzIGFuIGFycmF5IG9mIHN0b3JlIGtleXMuIFdpdGggdGhpcyBmb3JtLCB0aGUgc3RhdGVcbiAgICAqIGdldHRlciBpcyBjYWxsZWQgb25jZSB3aXRoIGFuIGFycmF5IG9mIHN0b3JlIGluc3RhbmNlcyAoaW4gdGhlIHNhbWUgb3JkZXJcbiAgICAqIGFzIHRoZSBzdG9yZSBrZXlzKS4gdGhlIGRlZmF1bHQgZ2V0dGVyIHBlcmZvcm1hbmNlIGEgcmVkdWNlIG9uIHRoZSBlbnRpcmVcbiAgICAqIHN0YXRlIGZvciBlYWNoIHN0b3JlLlxuICAgICpcbiAgICAqIFRoZSBsYXN0IGZvcm0gYWNjZXB0cyBhbiBvYmplY3Qgb2Ygc3RvcmUga2V5cyBtYXBwZWQgdG8gc3RhdGUgZ2V0dGVycy4gQXNcbiAgICAqIGEgc2hvcnRjdXQsIHlvdSBjYW4gcGFzcyBgbnVsbGAgYXMgYSBzdGF0ZSBnZXR0ZXIgdG8gdXNlIHRoZSBkZWZhdWx0XG4gICAgKiBzdGF0ZSBnZXR0ZXIuXG4gICAgKlxuICAgICogUmV0dXJucyB0aGUgY29tYmluZWQgaW5pdGlhbCBzdGF0ZSBvZiBhbGwgc3BlY2lmaWVkIHN0b3Jlcy5cbiAgICAqXG4gICAgKiBUaGlzIHdheSB5b3UgY2FuIHdyaXRlIGFsbCB0aGUgaW5pdGlhbGl6YXRpb24gYW5kIHVwZGF0ZSBsb2dpYyBpbiBhIHNpbmdsZVxuICAgICogbG9jYXRpb24sIHdpdGhvdXQgaGF2aW5nIHRvIG1lc3Mgd2l0aCBhZGRpbmcvcmVtb3ZpbmcgbGlzdGVuZXJzLlxuICAgICpcbiAgICAqIEB0eXBlIHtzdHJpbmd8YXJyYXl8b2JqZWN0fSBzdGF0ZUdldHRlck1hcCAtIG1hcCBvZiBrZXlzIHRvIGdldHRlcnNcbiAgICAqIEByZXR1cm5zIHtvYmplY3R9IENvbWJpbmVkIGluaXRpYWwgc3RhdGUgb2Ygc3RvcmVzXG4gICAgKi9cbiAgY29ubmVjdFRvU3RvcmVzKHN0YXRlR2V0dGVyTWFwID0ge30sIHN0YXRlR2V0dGVyID0gbnVsbCkge1xuICAgIGNvbnN0IGZsdXggPSB0aGlzLmdldEZsdXgoKTtcblxuICAgIGNvbnN0IGdldFN0b3JlID0gKGtleSkgPT4ge1xuICAgICAgY29uc3Qgc3RvcmUgPSBmbHV4LmdldFN0b3JlKGtleSk7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3RvcmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgY29ubmVjdFRvU3RvcmVzKCk6IFN0b3JlIHdpdGgga2V5ICcke2tleX0nIGRvZXMgbm90IGV4aXN0LmBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHN0YXRlR2V0dGVyTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3Qga2V5ID0gc3RhdGVHZXR0ZXJNYXA7XG4gICAgICBjb25zdCBzdG9yZSA9IGdldFN0b3JlKGtleSk7XG4gICAgICBjb25zdCBnZXR0ZXIgPSBzdGF0ZUdldHRlciB8fCBkZWZhdWx0U3RhdGVHZXR0ZXI7XG5cbiAgICAgIHRoaXMuX2ZsdXhTdGF0ZUdldHRlcnMucHVzaCh7IHN0b3Jlczogc3RvcmUsIGdldHRlciB9KTtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gY3JlYXRlU3RvcmVMaXN0ZW5lcih0aGlzLCBzdG9yZSwgZ2V0dGVyKTtcblxuICAgICAgc3RvcmUuYWRkTGlzdGVuZXIoJ2NoYW5nZScsIGxpc3RlbmVyKTtcbiAgICAgIHRoaXMuX2ZsdXhMaXN0ZW5lcnNba2V5XSA9IGxpc3RlbmVyO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZUdldHRlck1hcCkpIHtcbiAgICAgIGNvbnN0IHN0b3JlcyA9IHN0YXRlR2V0dGVyTWFwLm1hcChnZXRTdG9yZSk7XG4gICAgICBjb25zdCBnZXR0ZXIgPSBzdGF0ZUdldHRlciB8fCBkZWZhdWx0UmVkdWNlU3RhdGVHZXR0ZXI7XG5cbiAgICAgIHRoaXMuX2ZsdXhTdGF0ZUdldHRlcnMucHVzaCh7IHN0b3JlcywgZ2V0dGVyIH0pO1xuICAgICAgY29uc3QgbGlzdGVuZXIgPSBjcmVhdGVTdG9yZUxpc3RlbmVyKHRoaXMsIHN0b3JlcywgZ2V0dGVyKTtcblxuICAgICAgc3RhdGVHZXR0ZXJNYXAuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBzdG9yZSA9IHN0b3Jlc1tpbmRleF07XG4gICAgICAgIHN0b3JlLmFkZExpc3RlbmVyKCdjaGFuZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX2ZsdXhMaXN0ZW5lcnNba2V5XSA9IGxpc3RlbmVyO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgIGZvciAobGV0IGtleSBpbiBzdGF0ZUdldHRlck1hcCkge1xuICAgICAgICBjb25zdCBzdG9yZSA9IGdldFN0b3JlKGtleSk7XG4gICAgICAgIGNvbnN0IGdldHRlciA9IHN0YXRlR2V0dGVyTWFwW2tleV0gfHwgZGVmYXVsdFN0YXRlR2V0dGVyO1xuXG4gICAgICAgIHRoaXMuX2ZsdXhTdGF0ZUdldHRlcnMucHVzaCh7IHN0b3Jlczogc3RvcmUsIGdldHRlciB9KTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBjcmVhdGVTdG9yZUxpc3RlbmVyKHRoaXMsIHN0b3JlLCBnZXR0ZXIpO1xuXG4gICAgICAgIHN0b3JlLmFkZExpc3RlbmVyKCdjaGFuZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX2ZsdXhMaXN0ZW5lcnNba2V5XSA9IGxpc3RlbmVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldFN0b3JlU3RhdGUoKTtcbiAgfVxuXG59O1xuXG5jb25zdCBzdGF0aWNQcm9wZXJ0aWVzID0ge1xuICBjb250ZXh0VHlwZXM6IHtcbiAgICBmbHV4OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihGbHV4KSxcbiAgfSxcblxuICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgIGZsdXg6IFByb3BUeXBlcy5pbnN0YW5jZU9mKEZsdXgpLFxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIGNvbm5lY3RUb1N0b3JlczogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gICAgICBQcm9wVHlwZXMub2JqZWN0XG4gICAgXSksXG4gICAgZmx1eDogUHJvcFR5cGVzLmluc3RhbmNlT2YoRmx1eCksXG4gICAgcmVuZGVyOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBzdGF0ZUdldHRlcjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gIH0sXG59O1xuXG5leHBvcnQgeyBpbnN0YW5jZU1ldGhvZHMsIHN0YXRpY1Byb3BlcnRpZXMgfTtcblxuZnVuY3Rpb24gY3JlYXRlU3RvcmVMaXN0ZW5lcihjb21wb25lbnQsIHN0b3JlLCBzdG9yZVN0YXRlR2V0dGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlU3RhdGVHZXR0ZXIoc3RvcmUsIHRoaXMucHJvcHMpO1xuICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUpO1xuICB9LmJpbmQoY29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFN0YXRlR2V0dGVyKHN0b3JlKSB7XG4gIHJldHVybiBzdG9yZS5nZXRTdGF0ZUFzT2JqZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZWR1Y2VTdGF0ZUdldHRlcihzdG9yZXMpIHtcbiAgcmV0dXJuIHN0b3Jlcy5yZWR1Y2UoXG4gICAgKHJlc3VsdCwgc3RvcmUpID0+IGFzc2lnbihyZXN1bHQsIHN0b3JlLmdldFN0YXRlQXNPYmplY3QoKSksXG4gICAge31cbiAgKTtcbn1cbiJdfQ==